// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const deleteIssue = `-- name: DeleteIssue :exec
DELETE FROM issues WHERE id = ?
`

func (q *Queries) DeleteIssue(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteIssue, id)
	return err
}

const deleteIssueByIdentifier = `-- name: DeleteIssueByIdentifier :exec
DELETE FROM issues WHERE identifier = ?
`

func (q *Queries) DeleteIssueByIdentifier(ctx context.Context, identifier string) error {
	_, err := q.db.ExecContext(ctx, deleteIssueByIdentifier, identifier)
	return err
}

const deleteTeamIssues = `-- name: DeleteTeamIssues :exec
DELETE FROM issues WHERE team_id = ?
`

func (q *Queries) DeleteTeamIssues(ctx context.Context, teamID string) error {
	_, err := q.db.ExecContext(ctx, deleteTeamIssues, teamID)
	return err
}

const getIssueByID = `-- name: GetIssueByID :one
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE id = ?
`

func (q *Queries) GetIssueByID(ctx context.Context, id string) (Issue, error) {
	row := q.db.QueryRowContext(ctx, getIssueByID, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.TeamID,
		&i.Title,
		&i.Description,
		&i.StateID,
		&i.StateName,
		&i.StateType,
		&i.AssigneeID,
		&i.AssigneeEmail,
		&i.Priority,
		&i.ProjectID,
		&i.ProjectName,
		&i.CycleID,
		&i.CycleName,
		&i.ParentID,
		&i.DueDate,
		&i.Estimate,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SyncedAt,
		&i.Data,
	)
	return i, err
}

const getIssueByIdentifier = `-- name: GetIssueByIdentifier :one
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE identifier = ?
`

func (q *Queries) GetIssueByIdentifier(ctx context.Context, identifier string) (Issue, error) {
	row := q.db.QueryRowContext(ctx, getIssueByIdentifier, identifier)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.TeamID,
		&i.Title,
		&i.Description,
		&i.StateID,
		&i.StateName,
		&i.StateType,
		&i.AssigneeID,
		&i.AssigneeEmail,
		&i.Priority,
		&i.ProjectID,
		&i.ProjectName,
		&i.CycleID,
		&i.CycleName,
		&i.ParentID,
		&i.DueDate,
		&i.Estimate,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SyncedAt,
		&i.Data,
	)
	return i, err
}

const getIssueUpdatedAt = `-- name: GetIssueUpdatedAt :one


SELECT updated_at FROM issues WHERE id = ?
`

// Full-text search queries are handled with raw SQL (FTS5 not supported by sqlc)
// See internal/db/search.go for FTS implementation
// Bulk operations for sync
func (q *Queries) GetIssueUpdatedAt(ctx context.Context, id string) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getIssueUpdatedAt, id)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}

const getLatestTeamIssueUpdatedAt = `-- name: GetLatestTeamIssueUpdatedAt :one
SELECT MAX(updated_at) FROM issues WHERE team_id = ?
`

func (q *Queries) GetLatestTeamIssueUpdatedAt(ctx context.Context, teamID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLatestTeamIssueUpdatedAt, teamID)
	var max interface{}
	err := row.Scan(&max)
	return max, err
}

const getSyncMeta = `-- name: GetSyncMeta :one

SELECT team_id, last_synced_at, last_issue_updated_at, issue_count FROM sync_meta WHERE team_id = ?
`

// Sync metadata queries
func (q *Queries) GetSyncMeta(ctx context.Context, teamID string) (SyncMetum, error) {
	row := q.db.QueryRowContext(ctx, getSyncMeta, teamID)
	var i SyncMetum
	err := row.Scan(
		&i.TeamID,
		&i.LastSyncedAt,
		&i.LastIssueUpdatedAt,
		&i.IssueCount,
	)
	return i, err
}

const getTeam = `-- name: GetTeam :one

SELECT id, "key", name, icon, created_at, updated_at, synced_at FROM teams WHERE id = ?
`

// Teams queries
func (q *Queries) GetTeam(ctx context.Context, id string) (Team, error) {
	row := q.db.QueryRowContext(ctx, getTeam, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Name,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SyncedAt,
	)
	return i, err
}

const getTeamByKey = `-- name: GetTeamByKey :one
SELECT id, "key", name, icon, created_at, updated_at, synced_at FROM teams WHERE key = ?
`

func (q *Queries) GetTeamByKey(ctx context.Context, key string) (Team, error) {
	row := q.db.QueryRowContext(ctx, getTeamByKey, key)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Name,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SyncedAt,
	)
	return i, err
}

const getTeamIssueCount = `-- name: GetTeamIssueCount :one
SELECT COUNT(*) FROM issues WHERE team_id = ?
`

func (q *Queries) GetTeamIssueCount(ctx context.Context, teamID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTeamIssueCount, teamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalIssueCount = `-- name: GetTotalIssueCount :one
SELECT COUNT(*) FROM issues
`

func (q *Queries) GetTotalIssueCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalIssueCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listAllIdentifiers = `-- name: ListAllIdentifiers :many

SELECT identifier, team_id FROM issues ORDER BY identifier
`

type ListAllIdentifiersRow struct {
	Identifier string `json:"identifier"`
	TeamID     string `json:"team_id"`
}

// Label-based queries (labels stored in JSON data column)
// These require extracting from JSON - keeping simple queries here,
// complex label queries will be done in Go code
func (q *Queries) ListAllIdentifiers(ctx context.Context) ([]ListAllIdentifiersRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllIdentifiers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllIdentifiersRow{}
	for rows.Next() {
		var i ListAllIdentifiersRow
		if err := rows.Scan(&i.Identifier, &i.TeamID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSyncMeta = `-- name: ListSyncMeta :many
SELECT team_id, last_synced_at, last_issue_updated_at, issue_count FROM sync_meta
`

func (q *Queries) ListSyncMeta(ctx context.Context) ([]SyncMetum, error) {
	rows, err := q.db.QueryContext(ctx, listSyncMeta)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncMetum{}
	for rows.Next() {
		var i SyncMetum
		if err := rows.Scan(
			&i.TeamID,
			&i.LastSyncedAt,
			&i.LastIssueUpdatedAt,
			&i.IssueCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIdentifiers = `-- name: ListTeamIdentifiers :many
SELECT identifier FROM issues WHERE team_id = ? ORDER BY identifier
`

func (q *Queries) ListTeamIdentifiers(ctx context.Context, teamID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIdentifiers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var identifier string
		if err := rows.Scan(&identifier); err != nil {
			return nil, err
		}
		items = append(items, identifier)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssueIDs = `-- name: ListTeamIssueIDs :many
SELECT id, updated_at FROM issues WHERE team_id = ? ORDER BY updated_at DESC
`

type ListTeamIssueIDsRow struct {
	ID        string    `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) ListTeamIssueIDs(ctx context.Context, teamID string) ([]ListTeamIssueIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssueIDs, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTeamIssueIDsRow{}
	for rows.Next() {
		var i ListTeamIssueIDsRow
		if err := rows.Scan(&i.ID, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssues = `-- name: ListTeamIssues :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? ORDER BY updated_at DESC
`

func (q *Queries) ListTeamIssues(ctx context.Context, teamID string) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssues, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByAssignee = `-- name: ListTeamIssuesByAssignee :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND assignee_id = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByAssigneeParams struct {
	TeamID     string         `json:"team_id"`
	AssigneeID sql.NullString `json:"assignee_id"`
}

func (q *Queries) ListTeamIssuesByAssignee(ctx context.Context, arg ListTeamIssuesByAssigneeParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByAssignee, arg.TeamID, arg.AssigneeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByAssigneeEmail = `-- name: ListTeamIssuesByAssigneeEmail :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND assignee_email = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByAssigneeEmailParams struct {
	TeamID        string         `json:"team_id"`
	AssigneeEmail sql.NullString `json:"assignee_email"`
}

func (q *Queries) ListTeamIssuesByAssigneeEmail(ctx context.Context, arg ListTeamIssuesByAssigneeEmailParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByAssigneeEmail, arg.TeamID, arg.AssigneeEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByCycle = `-- name: ListTeamIssuesByCycle :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND cycle_id = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByCycleParams struct {
	TeamID  string         `json:"team_id"`
	CycleID sql.NullString `json:"cycle_id"`
}

func (q *Queries) ListTeamIssuesByCycle(ctx context.Context, arg ListTeamIssuesByCycleParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByCycle, arg.TeamID, arg.CycleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByCycleName = `-- name: ListTeamIssuesByCycleName :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND cycle_name = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByCycleNameParams struct {
	TeamID    string         `json:"team_id"`
	CycleName sql.NullString `json:"cycle_name"`
}

func (q *Queries) ListTeamIssuesByCycleName(ctx context.Context, arg ListTeamIssuesByCycleNameParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByCycleName, arg.TeamID, arg.CycleName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByParent = `-- name: ListTeamIssuesByParent :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE parent_id = ? ORDER BY updated_at DESC
`

func (q *Queries) ListTeamIssuesByParent(ctx context.Context, parentID sql.NullString) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByPriority = `-- name: ListTeamIssuesByPriority :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND priority = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByPriorityParams struct {
	TeamID   string        `json:"team_id"`
	Priority sql.NullInt64 `json:"priority"`
}

func (q *Queries) ListTeamIssuesByPriority(ctx context.Context, arg ListTeamIssuesByPriorityParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByPriority, arg.TeamID, arg.Priority)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByProject = `-- name: ListTeamIssuesByProject :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND project_id = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByProjectParams struct {
	TeamID    string         `json:"team_id"`
	ProjectID sql.NullString `json:"project_id"`
}

func (q *Queries) ListTeamIssuesByProject(ctx context.Context, arg ListTeamIssuesByProjectParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByProject, arg.TeamID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByProjectName = `-- name: ListTeamIssuesByProjectName :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND project_name = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByProjectNameParams struct {
	TeamID      string         `json:"team_id"`
	ProjectName sql.NullString `json:"project_name"`
}

func (q *Queries) ListTeamIssuesByProjectName(ctx context.Context, arg ListTeamIssuesByProjectNameParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByProjectName, arg.TeamID, arg.ProjectName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByState = `-- name: ListTeamIssuesByState :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND state_id = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByStateParams struct {
	TeamID  string         `json:"team_id"`
	StateID sql.NullString `json:"state_id"`
}

func (q *Queries) ListTeamIssuesByState(ctx context.Context, arg ListTeamIssuesByStateParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByState, arg.TeamID, arg.StateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByStateName = `-- name: ListTeamIssuesByStateName :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND state_name = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByStateNameParams struct {
	TeamID    string         `json:"team_id"`
	StateName sql.NullString `json:"state_name"`
}

func (q *Queries) ListTeamIssuesByStateName(ctx context.Context, arg ListTeamIssuesByStateNameParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByStateName, arg.TeamID, arg.StateName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamIssuesByStateType = `-- name: ListTeamIssuesByStateType :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND state_type = ? ORDER BY updated_at DESC
`

type ListTeamIssuesByStateTypeParams struct {
	TeamID    string         `json:"team_id"`
	StateType sql.NullString `json:"state_type"`
}

func (q *Queries) ListTeamIssuesByStateType(ctx context.Context, arg ListTeamIssuesByStateTypeParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamIssuesByStateType, arg.TeamID, arg.StateType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamUnassignedIssues = `-- name: ListTeamUnassignedIssues :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE team_id = ? AND assignee_id IS NULL ORDER BY updated_at DESC
`

func (q *Queries) ListTeamUnassignedIssues(ctx context.Context, teamID string) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listTeamUnassignedIssues, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT id, "key", name, icon, created_at, updated_at, synced_at FROM teams ORDER BY name
`

func (q *Queries) ListTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, listTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Name,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAssignedIssues = `-- name: ListUserAssignedIssues :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE assignee_id = ? ORDER BY updated_at DESC
`

func (q *Queries) ListUserAssignedIssues(ctx context.Context, assigneeID sql.NullString) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listUserAssignedIssues, assigneeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAssignedIssuesByEmail = `-- name: ListUserAssignedIssuesByEmail :many
SELECT id, identifier, team_id, title, description, state_id, state_name, state_type, assignee_id, assignee_email, priority, project_id, project_name, cycle_id, cycle_name, parent_id, due_date, estimate, url, created_at, updated_at, synced_at, data FROM issues WHERE assignee_email = ? ORDER BY updated_at DESC
`

func (q *Queries) ListUserAssignedIssuesByEmail(ctx context.Context, assigneeEmail sql.NullString) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listUserAssignedIssuesByEmail, assigneeEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.TeamID,
			&i.Title,
			&i.Description,
			&i.StateID,
			&i.StateName,
			&i.StateType,
			&i.AssigneeID,
			&i.AssigneeEmail,
			&i.Priority,
			&i.ProjectID,
			&i.ProjectName,
			&i.CycleID,
			&i.CycleName,
			&i.ParentID,
			&i.DueDate,
			&i.Estimate,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SyncedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertIssue = `-- name: UpsertIssue :exec
INSERT INTO issues (
    id, identifier, team_id, title, description,
    state_id, state_name, state_type,
    assignee_id, assignee_email, priority,
    project_id, project_name, cycle_id, cycle_name,
    parent_id, due_date, estimate, url,
    created_at, updated_at, synced_at, data
) VALUES (
    ?, ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?, ?
) ON CONFLICT(id) DO UPDATE SET
    identifier = excluded.identifier,
    team_id = excluded.team_id,
    title = excluded.title,
    description = excluded.description,
    state_id = excluded.state_id,
    state_name = excluded.state_name,
    state_type = excluded.state_type,
    assignee_id = excluded.assignee_id,
    assignee_email = excluded.assignee_email,
    priority = excluded.priority,
    project_id = excluded.project_id,
    project_name = excluded.project_name,
    cycle_id = excluded.cycle_id,
    cycle_name = excluded.cycle_name,
    parent_id = excluded.parent_id,
    due_date = excluded.due_date,
    estimate = excluded.estimate,
    url = excluded.url,
    created_at = excluded.created_at,
    updated_at = excluded.updated_at,
    synced_at = excluded.synced_at,
    data = excluded.data
`

type UpsertIssueParams struct {
	ID            string          `json:"id"`
	Identifier    string          `json:"identifier"`
	TeamID        string          `json:"team_id"`
	Title         string          `json:"title"`
	Description   sql.NullString  `json:"description"`
	StateID       sql.NullString  `json:"state_id"`
	StateName     sql.NullString  `json:"state_name"`
	StateType     sql.NullString  `json:"state_type"`
	AssigneeID    sql.NullString  `json:"assignee_id"`
	AssigneeEmail sql.NullString  `json:"assignee_email"`
	Priority      sql.NullInt64   `json:"priority"`
	ProjectID     sql.NullString  `json:"project_id"`
	ProjectName   sql.NullString  `json:"project_name"`
	CycleID       sql.NullString  `json:"cycle_id"`
	CycleName     sql.NullString  `json:"cycle_name"`
	ParentID      sql.NullString  `json:"parent_id"`
	DueDate       sql.NullString  `json:"due_date"`
	Estimate      sql.NullFloat64 `json:"estimate"`
	Url           sql.NullString  `json:"url"`
	CreatedAt     time.Time       `json:"created_at"`
	UpdatedAt     time.Time       `json:"updated_at"`
	SyncedAt      time.Time       `json:"synced_at"`
	Data          json.RawMessage `json:"data"`
}

func (q *Queries) UpsertIssue(ctx context.Context, arg UpsertIssueParams) error {
	_, err := q.db.ExecContext(ctx, upsertIssue,
		arg.ID,
		arg.Identifier,
		arg.TeamID,
		arg.Title,
		arg.Description,
		arg.StateID,
		arg.StateName,
		arg.StateType,
		arg.AssigneeID,
		arg.AssigneeEmail,
		arg.Priority,
		arg.ProjectID,
		arg.ProjectName,
		arg.CycleID,
		arg.CycleName,
		arg.ParentID,
		arg.DueDate,
		arg.Estimate,
		arg.Url,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.SyncedAt,
		arg.Data,
	)
	return err
}

const upsertSyncMeta = `-- name: UpsertSyncMeta :exec
INSERT INTO sync_meta (team_id, last_synced_at, last_issue_updated_at, issue_count)
VALUES (?, ?, ?, ?)
ON CONFLICT(team_id) DO UPDATE SET
    last_synced_at = excluded.last_synced_at,
    last_issue_updated_at = excluded.last_issue_updated_at,
    issue_count = excluded.issue_count
`

type UpsertSyncMetaParams struct {
	TeamID             string        `json:"team_id"`
	LastSyncedAt       time.Time     `json:"last_synced_at"`
	LastIssueUpdatedAt sql.NullTime  `json:"last_issue_updated_at"`
	IssueCount         sql.NullInt64 `json:"issue_count"`
}

func (q *Queries) UpsertSyncMeta(ctx context.Context, arg UpsertSyncMetaParams) error {
	_, err := q.db.ExecContext(ctx, upsertSyncMeta,
		arg.TeamID,
		arg.LastSyncedAt,
		arg.LastIssueUpdatedAt,
		arg.IssueCount,
	)
	return err
}

const upsertTeam = `-- name: UpsertTeam :exec
INSERT INTO teams (id, key, name, icon, created_at, updated_at, synced_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    key = excluded.key,
    name = excluded.name,
    icon = excluded.icon,
    created_at = excluded.created_at,
    updated_at = excluded.updated_at,
    synced_at = excluded.synced_at
`

type UpsertTeamParams struct {
	ID        string         `json:"id"`
	Key       string         `json:"key"`
	Name      string         `json:"name"`
	Icon      sql.NullString `json:"icon"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
	SyncedAt  time.Time      `json:"synced_at"`
}

func (q *Queries) UpsertTeam(ctx context.Context, arg UpsertTeamParams) error {
	_, err := q.db.ExecContext(ctx, upsertTeam,
		arg.ID,
		arg.Key,
		arg.Name,
		arg.Icon,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.SyncedAt,
	)
	return err
}
